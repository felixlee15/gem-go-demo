package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"go-demo/ent/user"
	"go-demo/internal/pkg/graph/generated"
	"go-demo/internal/pkg/graph/models"
	"strconv"
	"time"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, name string, email string) (*models.User, error) {
	u, err := r.Client.User.Create().SetName(name).SetEmail(email).Save(ctx)
	if err != nil {
		return nil, err
	}
	return &models.User{
		ID:    strconv.Itoa(u.ID),
		Name:  u.Name,
		Email: u.Email,
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, title string, userID string) (*models.Task, error) {
	uid, _ := strconv.Atoi(userID)
	fmt.Println("heheheheh")
	fmt.Println(uid)
	owner, err := r.Client.User.Query().Where(user.ID(uid)).All(ctx)
	if err != nil {
		return nil, err
	}

	fmt.Println("owner: ", owner)

	t, err := r.Client.Task.Create().SetTitle(title).SetOwner(owner[0]).Save(ctx)
	if err != nil {
		return nil, err
	}

	fmt.Println("heheheheh1")
	fmt.Println(t)
	fmt.Println(t.Edges)
	fmt.Println(t.Edges.Owner)
	return &models.Task{
		ID:        strconv.Itoa(t.ID),
		Title:     t.Title,
		Completed: t.Completed,
		Owner: &models.User{
			ID:    strconv.Itoa(owner[0].ID),
			Name:  owner[0].Name,
			Email: owner[0].Email,
		},
	}, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, taskID string, completed bool) (*models.Task, error) {
	taskIDInt, _ := strconv.Atoi(taskID)
	t, err := r.Client.Task.Get(ctx, taskIDInt)
	if err != nil {
		return nil, err
	}

	update := r.Client.Task.UpdateOne(t).SetCompleted(completed)
	if completed {
		update.SetCompletedAt(time.Now())
	} else {
		update.ClearCompletedAt()
	}

	_, err = update.Save(ctx)
	if err != nil {
		return nil, err
	}

	owner, err := t.QueryOwner().All(ctx)
	if err != nil {
		return nil, err
	}

	return &models.Task{
		ID:          strconv.Itoa(t.ID),
		Title:       t.Title,
		Completed:   t.Completed,
		CompletedAt: t.CompletedAt,
		Owner: &models.User{
			ID:    strconv.Itoa(owner[0].ID),
			Name:  owner[0].Name,
			Email: owner[0].Email,
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
	users, err := r.Client.User.Query().WithTasks().All(ctx)
	if err != nil {
		return nil, err
	}
	res := make([]*models.User, len(users))
	for i, u := range users {
		tasks := make([]*models.Task, len(u.Edges.Tasks))
		for j, t := range u.Edges.Tasks {
			tasks[j] = &models.Task{
				ID:        strconv.Itoa(t.ID),
				Title:     t.Title,
				Completed: t.Completed,
			}
		}
		res[i] = &models.User{
			ID:    strconv.Itoa(u.ID),
			Name:  u.Name,
			Email: u.Email,
			Tasks: tasks,
		}
	}
	return res, nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context) ([]*models.Task, error) {
	tasks, err := r.Client.Task.Query().WithOwner().All(ctx)
	if err != nil {
		return nil, err
	}
	res := make([]*models.Task, len(tasks))
	for i, t := range tasks {
		res[i] = &models.Task{
			ID:        strconv.Itoa(t.ID),
			Title:     t.Title,
			Completed: t.Completed,
			Owner: &models.User{
				ID:    strconv.Itoa(t.Edges.Owner.ID),
				Name:  t.Edges.Owner.Name,
				Email: t.Edges.Owner.Email,
			},
		}
	}
	return res, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
